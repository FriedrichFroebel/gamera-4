<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>The Gamera C++ Image API</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="the-gamera-c-image-api">
<h1 class="title">The Gamera C++ Image API</h1>

<p><strong>Last modified</strong>: November 23, 2022</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#data-model" id="toc-entry-2">Data model</a><ul>
<li><a class="reference internal" href="#memory-management-issues" id="toc-entry-3">Memory management issues</a></li>
<li><a class="reference internal" href="#image-types" id="toc-entry-4">Image types</a><ul>
<li><a class="reference internal" href="#imagedata-t-objects" id="toc-entry-5"><tt class="docutils literal">ImageData&lt;T&gt;</tt> objects</a></li>
<li><a class="reference internal" href="#imageview-t-objects" id="toc-entry-6"><tt class="docutils literal">ImageView&lt;T&gt;</tt> objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#image-factories" id="toc-entry-7">Image factories</a><ul>
<li><a class="reference internal" href="#typeidimagefactory" id="toc-entry-8">TypeIdImageFactory</a></li>
<li><a class="reference internal" href="#imagefactory" id="toc-entry-9">ImageFactory</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#accessing-pixels" id="toc-entry-10">Accessing pixels</a><ul>
<li><a class="reference internal" href="#different-interfaces" id="toc-entry-11">Different interfaces</a><ul>
<li><a class="reference internal" href="#get-and-set-methods" id="toc-entry-12"><tt class="docutils literal">get</tt> and <tt class="docutils literal">set</tt> methods</a></li>
<li><a class="reference internal" href="#c-style-2-dimensional-array" id="toc-entry-13">C-style 2-dimensional array</a></li>
<li><a class="reference internal" href="#iterators" id="toc-entry-14">Iterators</a><ul>
<li><a class="reference internal" href="#vector-iterator" id="toc-entry-15">Vector iterator</a></li>
<li><a class="reference internal" href="#row-column-iterators" id="toc-entry-16">Row/column iterators</a></li>
<li><a class="reference internal" href="#two-dimensional-iterators" id="toc-entry-17">Two-dimensional iterators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#speed-tests" id="toc-entry-18">Speed tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#making-generic-programming-work" id="toc-entry-19">Making generic programming work</a><ul>
<li><a class="reference internal" href="#black-and-white" id="toc-entry-20">Black and white</a></li>
<li><a class="reference internal" href="#writing-a-specialized-function" id="toc-entry-21">Writing a specialized function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#connected-components" id="toc-entry-22">Connected components</a></li>
<li><a class="reference internal" href="#multi-label-connected-components" id="toc-entry-23">Multi-label connected components</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#toc-entry-1">Introduction</a></h1>
<p>This document describes how to manipulate Gamera images from C++.
This deals primarily with low-level (pixel-level) operations.</p>
</div>
<div class="section" id="data-model">
<h1><a class="toc-backref" href="#toc-entry-2">Data model</a></h1>
<p>Gamera uses a &quot;shared&quot; data model.  This means that
different &quot;views&quot; are applied to the same &quot;data.&quot;  Views may only look
at a subset of the data, or they may change how the data is presented
to the programmer. The goal of decoupling the &quot;view&quot; from the &quot;data&quot; is
to allow a &quot;view&quot; on the data to be a very lightweight object. This
allows it to be passed by value with little worry about performance. This
also allows the processing of a portion of an image as if it were an entire
image.</p>
<p>For example, to create a new image, the programmer must first create
the data:</p>
<div class="highlight"><pre><span></span><span class="n">OneBitImageData</span><span class="w"> </span><span class="nf">image_data</span><span class="p">(</span><span class="n">Dim</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>This creates data that is 50 pixels width and 50 pixels high, and has
a logical origin of (0, 0).</p>
<p>Then you can create a view on all of the data:</p>
<div class="highlight"><pre><span></span><span class="n">OneBitImageView</span><span class="w"> </span><span class="nf">image_view</span><span class="p">(</span><span class="n">image_data</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Later, if you want to view only a subset of the data, you can use a
different overloaded version of the view constructor:</p>
<div class="highlight"><pre><span></span><span class="n">OneBitImageView</span><span class="w"> </span><span class="nf">subimage_view</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">),</span><span class="w"> </span><span class="n">Dim</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>This will create a view on the image from (25, 25) that is 10 pixels
tall and wide, i.e. the lower-right corner will be at (35, 35).  An
alternate way to do this would be to specify two points:</p>
<div class="highlight"><pre><span></span><span class="n">OneBitImageView</span><span class="w"> </span><span class="nf">subimage_view</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>The different constructor forms are discussed in more detail in the
<a class="reference internal" href="#imageview-t-objects">ImageView&lt;T&gt; objects</a> section.</p>
<div class="section" id="memory-management-issues">
<h2><a class="toc-backref" href="#toc-entry-3">Memory management issues</a></h2>
<p>Since multiple &quot;views&quot; can use the same &quot;data,&quot; one must be careful
about prematurely deallocating data objects, or there may be views left
around that &quot;point&quot; to deallocated data.  Accessing the data through
the view is unchecked and could result in a segmentation fault.</p>
<p>Another common mistake is to deallocate all views on a given data
object, forgetting to deallocate the data itself, resulting in a
memory leak.  Since there is no reference counting on the C++ side,
deallocation of all views does not automatically trigger deallocation
of the underlying data.  For example:</p>
<div class="highlight"><pre><span></span><span class="n">OneBitImageData</span><span class="w"> </span><span class="n">image_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OneBitImageData</span><span class="p">(</span><span class="n">Dim</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">OneBitImageView</span><span class="w"> </span><span class="n">image_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OneBitImageView</span><span class="p">(</span><span class="o">*</span><span class="n">image_data</span><span class="p">);</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="k">delete</span><span class="w"> </span><span class="n">image_view</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span><span class="w"> </span><span class="c1">// Don&#39;t forget to delete the data</span>
<span class="k">delete</span><span class="w"> </span><span class="n">image_view</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Of course, if the new image data is the result of a plugin function,
it will be returned to the caller.  When a pointer to an image
view (<tt class="docutils literal">ImageView*</tt> or one of its subclasses) is returned to Python, it will
participate in Python memory management, and both the view and data
will eventually be deallocated automatically.  When an <tt class="docutils literal">ImageView*</tt>
is returned to another C++ function, that function is
responsible for deallocating the view and data, unless it in turn is passing
it back to Python.</p>
<p>Fortunately, things are much easier on the Python side, since the
number of views that point to a data object are reference counted, so
the data object is kept around only as long as there is at least one
view looking at it.</p>
<p>Take for example the following interactive Python session:</p>
<div class="highlight"><pre><span></span><span class="n">Python</span> <span class="mf">2.3.4</span> <span class="p">(</span><span class="c1">#1, Oct 26 2004, 16:42:40)</span>
<span class="p">[</span><span class="n">GCC</span> <span class="mf">3.4.2</span> <span class="mi">20041017</span> <span class="p">(</span><span class="n">Red</span> <span class="n">Hat</span> <span class="mf">3.4.2</span><span class="o">-</span><span class="mf">6.</span><span class="n">fc3</span><span class="p">)]</span> <span class="n">on</span> <span class="n">linux2</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">gamera.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">init_gamera</span><span class="p">()</span>
<span class="n">Loading</span> <span class="n">plugins</span><span class="p">:</span> <span class="o">----------------------------------------</span>
<span class="n">arithmetic</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">convolution</span><span class="p">,</span> <span class="n">corelation</span><span class="p">,</span> <span class="n">deformation</span><span class="p">,</span> <span class="n">draw</span><span class="p">,</span>
<span class="n">edgedetect</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">gui_support</span><span class="p">,</span> <span class="n">id_name_matching</span><span class="p">,</span>
<span class="n">image_conversion</span><span class="p">,</span> <span class="n">image_utilities</span><span class="p">,</span> <span class="n">listutilities</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
<span class="n">misc_filters</span><span class="p">,</span> <span class="n">morphology</span><span class="p">,</span> <span class="n">png_support</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">runlength</span><span class="p">,</span>
<span class="n">segmentation</span><span class="p">,</span> <span class="n">structural</span><span class="p">,</span> <span class="n">thinning</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tiff_support</span><span class="p">,</span> <span class="n">contour</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="s2">&quot;test.tiff&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">orig</span>
<span class="c1"># ImageData dealloc, because the only view pointing to it (orig) has been deleted.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="s2">&quot;test.tiff&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">otsu_threshold</span><span class="p">()</span>
<span class="c1"># ImageData dealloc, because the pointer stored in orig has been replaced</span>
<span class="c1"># with a new onebit image.  This effect is fairly subtle.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ccs</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">cc_analysis</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">orig</span>
<span class="c1"># No ImageData dealloc, since the ccs list contains views on the data.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">ccs</span>
<span class="c1"># ImageData dealloc, because the remaining views on the data have been destroyed.</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="section" id="image-types">
<h2><a class="toc-backref" href="#toc-entry-4">Image types</a></h2>
<p>You should probably familiarize yourself with different Gamera <a class="reference external" href="image_types.html">image
types</a> before reading further.</p>
<div class="section" id="imagedata-t-objects">
<h3><a class="toc-backref" href="#toc-entry-5"><tt class="docutils literal">ImageData&lt;T&gt;</tt> objects</a></h3>
<p>Data objects are instances of the <tt class="docutils literal">ImageData&lt;T&gt;</tt> class (in
<tt class="docutils literal">include/image_data.hpp</tt>) where <tt class="docutils literal">T</tt> is the pixel type.
If you wish to use run-length encoding to store the data, you can use
the <tt class="docutils literal">RleImageData&lt;T&gt;</tt> class.  These classes both have the same
interface and are completely interchangeable, but will exhibit
different algorithmic complexities.</p>
<p>There are some typedefs in <tt class="docutils literal">image_types.hpp</tt> to make creating
different kinds of image data objects more convenient:</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">  Image Data</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageData</span><span class="o">&lt;</span><span class="n">GreyScalePixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GreyScaleImageData</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageData</span><span class="o">&lt;</span><span class="n">Grey16Pixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Grey16ImageData</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageData</span><span class="o">&lt;</span><span class="n">FloatPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FloatImageData</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageData</span><span class="o">&lt;</span><span class="n">RGBPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RGBImageData</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageData</span><span class="o">&lt;</span><span class="n">OneBitPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OneBitImageData</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">RleImageData</span><span class="o">&lt;</span><span class="n">OneBitPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OneBitRleImageData</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>There are a few different constructors available for data objects:</p>
<div class="highlight"><pre><span></span><span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Dim</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Dim</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">);</span><span class="w"> </span><span class="c1">// offset == (0, 0)</span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Size</span><span class="o">&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Size</span><span class="o">&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// offset == (0, 0)</span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rect</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>There are also some deprecated forms that you may see in legacy code,
but which are no longer supported since they are not consistent about
specifying <em>x</em> before <em>y</em>:</p>
<div class="highlight"><pre><span></span><span class="n">ImageData</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">nrows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ncols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Size</span><span class="o">&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Dimensions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">page_offset_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The <em>offset</em> arguments are used to specify a logical offset of the
data.  For instance, if the image data is from part of the page, the
upper left corner may not be logically (0, 0).  This is purely for
logical purposes when your system needs to know the relative positions
of image bounding boxes, and does not affect the size of the image
data created in any way.</p>
<p>The <tt class="docutils literal">Size</tt> and <tt class="docutils literal">Dim</tt> classes are simple ways of storing
sizes and dimensions defined in <tt class="docutils literal">gamera/dimensions.hpp</tt>.  (See the
<a class="reference external" href="dimension_types.html">Dimension types</a> chapter for more information). <tt class="docutils literal">Size(w,
h)</tt> is always equal to <tt class="docutils literal">Dim(w + 1, h + 1)</tt>.  Both forms are
supported to make it easier to adapt existing algorithms that use one
or the other standard.</p>
<p>While there are other public members and methods to the <tt class="docutils literal">ImageData</tt>
class, we do not recommend using any of them unless you really know
what you're doing.  All of the image data can be accessed much more
flexibly and conveniently through <tt class="docutils literal">ImageView</tt> objects.</p>
</div>
<div class="section" id="imageview-t-objects">
<h3><a class="toc-backref" href="#toc-entry-6"><tt class="docutils literal">ImageView&lt;T&gt;</tt> objects</a></h3>
<p>Views objects are instances of the <tt class="docutils literal">ImageView&lt;T&gt;</tt> class (in
<tt class="docutils literal">include/image_view.hpp</tt>), where <tt class="docutils literal">T</tt> is the data object type (a
templatization of <tt class="docutils literal">ImageData&lt;T&gt;</tt>).  There is also a special version
of <tt class="docutils literal">ImageView&lt;T&gt;</tt> for connected components,
<tt class="docutils literal">ConnectedComponent&lt;T&gt;</tt> defined in
<tt class="docutils literal">include/connected_components.hpp</tt>.  <a class="reference internal" href="#connected-components">Connected components</a> are
discussed below.</p>
<p>As with the data objects, there are some typedefs for convenience:</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">  ImageView</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">GreyScaleImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GreyScaleImageView</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">Grey16ImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Grey16ImageView</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">FloatImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FloatImageView</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">RGBImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RGBImageView</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">OneBitImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OneBitImageView</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ImageView</span><span class="o">&lt;</span><span class="n">OneBitRleImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OneBitRleImageView</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">  Connected-components</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ConnectedComponent</span><span class="o">&lt;</span><span class="n">OneBitImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cc</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">ConnectedComponent</span><span class="o">&lt;</span><span class="n">OneBitRleImageData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RleCc</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>There are a number of different ways to construct image views:</p>
<div class="highlight"><pre><span></span><span class="c1">// Creates a view covering all of the data</span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">);</span><span class="w"></span>

<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rect</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">upper_left</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lower_right</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">upper_left</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">Size</span><span class="o">&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">upper_left</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">Dim</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>There are also some deprecated forms that you may see in legacy code,
but which are no longer supported since they are not consistent about
specifying <em>x</em> before <em>y</em>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Creates a view with a specified bounding box</span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_y</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ncols</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageView</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">upper_left</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">Dimensions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_range_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal">Size</tt>, <tt class="docutils literal">Point</tt> and <tt class="docutils literal">Dim</tt> classes are simple ways of storing
sizes and dimensions defined in <tt class="docutils literal">gamera/dimensions.hpp</tt>.  (See the
<a class="reference external" href="dimension_types.html">Dimension types</a> chapter for more information).</p>
<p>Coordinates for any given bounding boxes are relative to the offset of
the underlying data.  Therefore:</p>
<div class="highlight"><pre><span></span><span class="c1">// Create data with a size of (64, 64) and an offset of (32, 32);</span>
<span class="n">OneBitImageData</span><span class="w"> </span><span class="nf">image_data</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">));</span><span class="w"></span>
<span class="c1">// This is a view over all of the data</span>
<span class="n">OneBitImageView</span><span class="w"> </span><span class="nf">image_view</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">),</span><span class="w"> </span><span class="n">Size</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">));</span><span class="w"></span>
<span class="c1">// This raises an exception, since it&#39;s out of range for the data</span>
<span class="n">OneBitImageView</span><span class="w"> </span><span class="nf">image_view</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Size</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>You can get the type of the pixels referenced by an <tt class="docutils literal">ImageView</tt>
using the expression <tt class="docutils literal">typename <span class="pre">T::value_type</span></tt>.</p>
</div>
</div>
<div class="section" id="image-factories">
<h2><a class="toc-backref" href="#toc-entry-7">Image factories</a></h2>
<p>There are other convenience classes for creating image types.</p>
<div class="section" id="typeidimagefactory">
<h3><a class="toc-backref" href="#toc-entry-8">TypeIdImageFactory</a></h3>
<p><tt class="docutils literal">TypeIdImageFactory</tt> is useful if you want to create an image of a
specific type based on a pair of integer constants.  For example, the
following code snippit creates a DENSE or RLE image based on an
integer constant passed in as a parameter to the function.  Note that
the types of each of the <tt class="docutils literal">TypeIdImageFactory</tt> s are different and
not polymorphic, so the interior function (<tt class="docutils literal">threshold_fill</tt>) must be
called from two locations.</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Image</span><span class="o">*</span><span class="w"> </span><span class="n">threshold</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">storage_format</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">storage_format</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DENSE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">TypeIdImageFactory</span><span class="o">&lt;</span><span class="n">ONEBIT</span><span class="p">,</span><span class="w"> </span><span class="n">DENSE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fact_type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">fact_type</span><span class="o">::</span><span class="n">image_type</span><span class="o">*</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact_type</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">origin</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">dim</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">threshold_fill</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">view</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">TypeIdImageFactory</span><span class="o">&lt;</span><span class="n">ONEBIT</span><span class="p">,</span><span class="w"> </span><span class="n">RLE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fact_type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">fact_type</span><span class="o">::</span><span class="n">image_type</span><span class="o">*</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact_type</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">origin</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">dim</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">threshold_fill</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">view</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="imagefactory">
<h3><a class="toc-backref" href="#toc-entry-9">ImageFactory</a></h3>
<p>It is a common use case to create a result image whose type is related
to the type of an input image.  In many cases, one could just use the
same type as the result type.  However, if a <tt class="docutils literal">Cc</tt> image type is
passed into a function, you would most likely want to return a regular
<tt class="docutils literal">OneBit</tt> image as a result.  <tt class="docutils literal">ImageFactory</tt> is designed to get
around this problem.  It will create an appropriate result type from
a given input type.  For example, see the following code snippet:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Image</span><span class="o">*</span><span class="w"> </span><span class="n">abutaleb_threshold</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">storage_format</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">average</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="accessing-pixels">
<h1><a class="toc-backref" href="#toc-entry-10">Accessing pixels</a></h1>
<p>One of the goals of the Gamera framework is to make it easy to
incorporate code from other image processing frameworks as painlessly
as possible.  Therefore, there are a number of interfaces that can be
used to access and process the underlying pixel data of an image.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whenever accessing individual pixels, the <tt class="docutils literal">row</tt> and <tt class="docutils literal">col</tt>
given are relative to the offsets of the view or the
underlying data.  In other words <tt class="docutils literal">.get(0,0)</tt> will always return
the pixel in the upper-left hand corner of the view.  This makes it
easier for algorithms that work on the pixels of a view to ignore
the complexity of the &quot;shared&quot; data model.</p>
</div>
<div class="section" id="different-interfaces">
<h2><a class="toc-backref" href="#toc-entry-11">Different interfaces</a></h2>
<p>The different interfaces for accessing pixels are discussed below:</p>
<div class="section" id="get-and-set-methods">
<h3><a class="toc-backref" href="#toc-entry-12"><tt class="docutils literal">get</tt> and <tt class="docutils literal">set</tt> methods</a></h3>
<p>This is perhaps the most straightforward way to access the pixels of
an image.  There are two public methods of <tt class="docutils literal">ImageView</tt>:</p>
<blockquote>
<ul class="simple">
<li>value_type <strong>get</strong> (const Point&amp; <em>point</em>)</li>
<li>void <strong>set</strong> (const Point&amp; <em>point</em>, value_type <em>value</em>)</li>
</ul>
</blockquote>
<p>There are also deprecated forms that you may see in legacy code:</p>
<blockquote>
<ul class="simple">
<li>value_type <strong>get</strong> (size_t <em>row</em>, size_t <em>col</em>)</li>
<li>void <strong>set</strong> (size_t <em>row</em>, size_t <em>col</em>, value_type <em>value</em>)</li>
</ul>
</blockquote>
<p><strong>get</strong> returns the value of the pixel at the given row and column.
<strong>set</strong> changes the pixel at the given row and column to the given
value.</p>
<p>An example using <tt class="docutils literal">get</tt> / <tt class="docutils literal">set</tt> over an entire image:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">test_get_set</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data_type</span><span class="w"> </span><span class="n">data_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">data_type</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">view_type</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">nrows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">ncols</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">new_view</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new_view</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="c-style-2-dimensional-array">
<h3><a class="toc-backref" href="#toc-entry-13">C-style 2-dimensional array</a></h3>
<p>An alternative is to use the notation of C-style 2-dimensional
arrays:</p>
<div class="highlight"><pre><span></span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="n">image</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>This interface is provided as a convenience to support the large body
of legacy code written in this style.  Note that <tt class="docutils literal"><span class="pre">[row][col]</span></tt> is the
reverse of get and set's <tt class="docutils literal">Point(x, y)</tt>.  Keep in mind, it is not really
a 2-dimensional array underneath -- this view is &quot;faked.&quot;</p>
<p>An example using the C-style 2-dimensional array interface:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">test_c_2d</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data_type</span><span class="w"> </span><span class="n">data_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">data_type</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">view_type</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">nrows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">ncols</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">new_view</span><span class="p">)[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new_view</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="iterators">
<h3><a class="toc-backref" href="#toc-entry-14">Iterators</a></h3>
<p>Iterators provide a lot of readability and convenience advantages over
the other approaches.</p>
<p>Gamera has three kinds of iterators:</p>
<ol class="arabic simple">
<li>Vector iterator: a one-dimensional iterator that iterates from the
upper left hand corner, left-to-right, top-to-bottom.</li>
<li>Row/column iterators: Iterates along either rows or columns.  Incrementing the iterator
moves one row down or one column to the right.  Calling <tt class="docutils literal">begin()</tt> on a <tt class="docutils literal">row_iterator</tt>,
returns a <tt class="docutils literal">col_iterator</tt> and vice versa.</li>
<li>Two-dimensional iterators: Provide free movement of the iterator in
any direction.</li>
</ol>
<p>The first two kinds of iterators follow the conventions of the C++ STL
enough that they can be used with STL algorithms.  All iterators are
available in <tt class="docutils literal">const</tt> and non-<tt class="docutils literal">const</tt> versions.  <tt class="docutils literal">const</tt>
iterators cannot change the underlying data.  If you have an image
passed into your function as a <tt class="docutils literal">const ImageView&lt;T&gt; &amp;</tt>, you will not
be able to change the pixels in the image, and thus will only be able
to get <tt class="docutils literal">const</tt> iterators from it.</p>
<p>Note that you can call <tt class="docutils literal">row( )</tt> or <tt class="docutils literal">col( )</tt> on any
iterator to obtain the current row and column position of the iterator.</p>
<p>All Gamera iterators can get/set their values in two ways, both of
which boiling down to exactly the same machine code, and therefore
having the same efficiency:</p>
<ol class="arabic simple">
<li>The standard &quot;C pointer-like&quot; way:</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1">// i is any iterator type</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ol class="arabic simple" start="2">
<li>Using <tt class="docutils literal">get</tt> and <tt class="docutils literal">set</tt> methods:</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1">// i is any iterator type</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="n">i</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="section" id="vector-iterator">
<h4><a class="toc-backref" href="#toc-entry-15">Vector iterator</a></h4>
<p>Vector iterators (<tt class="docutils literal"><span class="pre">ImageView&lt;T&gt;::vec_iterator</span></tt>) can be convenient when the operation works one pixel
at a time and does not need to be aware of any spatial relationships.</p>
<p>An example using <tt class="docutils literal">vec_iterators</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">test_vec_iterator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data_type</span><span class="w"> </span><span class="n">data_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">data_type</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">view_type</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_vec_iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">view_type</span><span class="o">::</span><span class="n">vec_iterator</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_view</span><span class="o">-&gt;</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// or  j.set(i.get() / 2);</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new_view</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Since the Gamera image iterators follow the STL iterator interface,
they can be used with builtin STL algorithms.  For instance, to fill
an entire image with white using the STL <tt class="docutils literal"><span class="pre">std::fill</span></tt> algorithm:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">fill_white</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_end</span><span class="p">(),</span><span class="w"> </span><span class="n">white</span><span class="p">(</span><span class="n">image</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="row-column-iterators">
<h4><a class="toc-backref" href="#toc-entry-16">Row/column iterators</a></h4>
<p>Sometimes it is necessary to have nested loops, one for rows and one
for columns.</p>
<p>The following is an example using row iterators (<tt class="docutils literal"><span class="pre">ImageView&lt;T&gt;::row_iterators</span></tt>) and
column iterators (<tt class="docutils literal"><span class="pre">ImageView&lt;T&gt;::col_iterators</span></tt>):</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">test_row_col_iterator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data_type</span><span class="w"> </span><span class="n">data_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">data_type</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">view_type</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_row_iterator</span><span class="w"> </span><span class="n">IteratorI</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">IteratorI</span><span class="w"> </span><span class="n">ir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">row_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">view_type</span><span class="o">::</span><span class="n">row_iterator</span><span class="w"> </span><span class="n">IteratorJ</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">IteratorJ</span><span class="w"> </span><span class="n">jr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_view</span><span class="o">-&gt;</span><span class="n">row_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">ir</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">row_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ir</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">jr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">IteratorI</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">IteratorJ</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">jc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jr</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ic</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">jc</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="n">jc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ic</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new_view</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The fun thing about row and column iterators is that they are
interchangeable.  If you wish to iterate through the image in column
major order instead, you could write:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">test_col_row_iterator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data_type</span><span class="w"> </span><span class="n">data_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ImageFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">view_type</span><span class="w"> </span><span class="n">view_type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">data_type</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">view_type</span><span class="o">*</span><span class="w"> </span><span class="n">new_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">view_type</span><span class="p">(</span><span class="o">*</span><span class="n">new_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_col_iterator</span><span class="w"> </span><span class="n">IteratorI</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">IteratorI</span><span class="w"> </span><span class="n">ir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">col_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">view_type</span><span class="o">::</span><span class="n">col_iterator</span><span class="w"> </span><span class="n">IteratorJ</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">IteratorJ</span><span class="w"> </span><span class="n">jr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_view</span><span class="o">-&gt;</span><span class="n">col_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">ir</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">col_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ir</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">jr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">IteratorI</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">IteratorJ</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">jc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jr</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ic</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">jc</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="n">jc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ic</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new_view</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Of course, that really should be templatized on the iterator type.
For an example of this, see <tt class="docutils literal">include/plugins/projections.hpp</tt>.</p>
<p>Row and column iterators also have methods that return the current row
and column (relative to the underlying data).  <tt class="docutils literal">i.row()</tt> returns the
current row and <tt class="docutils literal">i.col()</tt> returns the current column.</p>
</div>
<div class="section" id="two-dimensional-iterators">
<h4><a class="toc-backref" href="#toc-entry-17">Two-dimensional iterators</a></h4>
<p>Unlike the other kinds of iterators, two-dimensional iterators are a
long way from C++ STL convention.  The idea of these iterators was
borrowed from the <a class="reference external" href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA</a> library.  More documentation is available
there, but I've provided a short summary below.</p>
<p>You can obtain a two-dimensional iterator from an image using of
the following methods:</p>
<div class="highlight"><pre><span></span><span class="n">Iterator</span><span class="w"> </span><span class="nf">upperLeft</span><span class="p">();</span><span class="w"></span>
<span class="n">Iterator</span><span class="w"> </span><span class="nf">lowerRight</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>Once you have a two-dimensional iterator, you can move it using the
following:</p>
<div class="highlight"><pre><span></span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">Iterator</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="o">++</span><span class="n">i</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// move right</span>
<span class="o">--</span><span class="n">i</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// move left</span>
<span class="o">++</span><span class="n">i</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// move down</span>
<span class="o">--</span><span class="n">i</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// move up</span>
</pre></div>
<p>You can see that this gives more freedom and expressivity than the
other iterators.</p>
<p>When you assign one two-dimensional iterator to another, it is copied,
so there are no persistent connections between them.</p>
<div class="highlight"><pre><span></span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">Iterator</span><span class="w"> </span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">below</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">below</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">center</span><span class="p">;</span><span class="w"></span>
<span class="o">++</span><span class="n">below</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w">   </span><span class="c1">// &#39;below&#39; points to the pixel below &#39;center&#39;</span>
<span class="o">++</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;center&#39; moved.  &#39;below&#39; did not.</span>
</pre></div>
<p>You can also perform arithmetic on these iterators on the fly:</p>
<div class="highlight"><pre><span></span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">Iterator</span><span class="w"> </span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">below</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">below</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;center&#39; is not moved</span>
</pre></div>
<p>If you need to move in two dimensions at once, you can either add or subtract
a <tt class="docutils literal">Diff2D</tt> object from the iterator, or use the <tt class="docutils literal">operator()</tt>
method.</p>
<div class="highlight"><pre><span></span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">Iterator</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">relative</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Diff2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">// down and to the right</span>
<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">[</span><span class="n">Diff2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">    </span><span class="c1">// equivalent to above</span>
<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Diff2D</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="c1">// up and to the left</span>

<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Diff2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">// up and to the left</span>
<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Diff2D</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="c1">// down and to the right</span>

<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">            </span><span class="c1">// down and to the right</span>
<span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w">          </span><span class="c1">// up and to the left</span>
</pre></div>
<p>For an example of how two-dimensional iterators can be used in a more
real-world situation, see the <tt class="docutils literal">cc_analysis</tt> method in
<tt class="docutils literal">include/plugins/segmentation.py</tt>.</p>
</div>
</div>
<div class="section" id="speed-tests">
<h3><a class="toc-backref" href="#toc-entry-18">Speed tests</a></h3>
<p>The different interfaces are provided primarily to support different
programming styles.  However, they do not run at the same speed.</p>
<p>The following graph shows the relative speeds of different pixel
access methods (using the examples above).  These results are largely
processor and architecture dependent, so take them with a truckload of
salt.</p>
<img alt="images/pixel_access_runtimes.png" src="images/pixel_access_runtimes.png" />
<p>The performance of the 1-dimensional iterator is perhaps surprising,
since it appears to be the simplest code.  In fact, however,
<tt class="docutils literal">vec_iterators</tt> must support the image view model, and therefore do
basic &quot;range checking&quot; upon each increment.  This introduces some
overhead.</p>
<p>The row/column iterators in row major order (rows in the outer loop) is
the clear winner.  Since the underlying data is stored row major order,
accessing it in column major order is a major performance hit, in part
due to the extra pointer arithmetic and in part due to worse cache performance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any performance improvement should be justified only by
profiling on real-world data</p>
</div>
</div>
</div>
</div>
<div class="section" id="making-generic-programming-work">
<h1><a class="toc-backref" href="#toc-entry-19">Making generic programming work</a></h1>
<p>Everything discussed so far has been completely polymorphic: these techniques
should work identically on all types of images.  However, where the
images vary is in the pixel types themselves.  Careful programming
can keep your algorithms generic across all pixel types, but when
that is no longer possible, it is also possible to specialize
(i.e. write a special version of an algorithm for a particular pixel
type.)</p>
<p>First, let's cover some more details of the various pixel types
available in Gamera.  They are all defined in <tt class="docutils literal">include/pixel.hpp</tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal">RGB</tt></dt>
<dd>RGB pixels are represented by instances of the <tt class="docutils literal">Rgb</tt> class.
By default, each plane is represented by an 8-bit <tt class="docutils literal">unsigned char</tt>
The individual RGB planes can be get/set using the <tt class="docutils literal">red</tt>,
<tt class="docutils literal">green</tt> and <tt class="docutils literal">blue</tt> functions.  The values follow the
standard hardware conventions: larger values are higher
intensity.
There are also many utility methods
for converting the RGB pixel into other kinds of
values.  See <tt class="docutils literal">include/pixel.hpp</tt> for more information.
<tt class="docutils literal">Rgb</tt> instances are small enough (3 bytes) that you can safely pass
them by value without performance concerns.</dd>
<dt><tt class="docutils literal">GREYSCALE</tt></dt>
<dd>GreyScale pixels are 8-bit <tt class="docutils literal">unsigned char</tt> values in the range 0
- 255.  These also
follow the hardware convention that larger values are higher
intensity (white).</dd>
<dt><tt class="docutils literal">FLOAT</tt></dt>
<dd>Float pixels are 32-bit floating-point <tt class="docutils literal">float</tt> values.  They
follows the hardware convention that larger values are higher
intensity (white).  Unlike the integral pixel types, there is
no set range for the values (they can even be negative).  For
this reason, the Gamera display will always find the lowest
and highest values and then normalize the display to match the
dynamic range of the display hardware.  Floating point images
are most useful to represent non-image data, such as the
results of the convolution of two images.</dd>
<dt><tt class="docutils literal">ONEBIT</tt></dt>
<dd>OneBit pixels are 16-bit <tt class="docutils literal">unsigned char</tt> values.  Perhaps
confusingly, a value of 0 is white (which is usually
<tt class="docutils literal">background</tt> in most document images) and <em>all other values</em>
are black.  The extra bits of range are used when a connected
component analysis is performed.  Each connected component in
an image is assigned a <tt class="docutils literal">label</tt> value, and its pixels are
labeled using the value.  Since the directionality of OneBit
pixels is different from all other pixel types, care must be
taken when writing algorithms that accept OneBit images and
other images.</dd>
</dl>
<div class="section" id="black-and-white">
<h2><a class="toc-backref" href="#toc-entry-20">Black and white</a></h2>
<p>Convenience functions are provided to get and test values for white
and black pixels that work on all pixel types.</p>
<div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="n">pixel_traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">white</span><span class="p">();</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">pixel_traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">black</span><span class="p">();</span><span class="w"></span>
</pre></div>
<p>Return the values for white and black, respectively, for the given
pixel type <tt class="docutils literal">T</tt>.  Often, it is more convenient to get the pixel value
from the <tt class="docutils literal">ImageView</tt> type, and not the pixel type.  Therefore, the
functions</p>
<div class="highlight"><pre><span></span><span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="w"> </span><span class="nf">white</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_type</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="w"> </span><span class="nf">black</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image_type</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>are also provided.</p>
<p>You can also test whether a pixel is white or black using:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_white</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">pixel_value</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">is_black</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">pixel_value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="writing-a-specialized-function">
<h2><a class="toc-backref" href="#toc-entry-21">Writing a specialized function</a></h2>
<p>As specified in <a class="reference external" href="writing_plugins.html">Writing Gamera Plugins</a>, each plugin function
should be templatized to accept multiple image types.  Sometimes,
though, a single code base will not work for all images types, or
there are performance gains to be had by writing for a particular
image type.</p>
<p>The wrinkle that makes this less than straightforward is that you
often want to specialize on the <strong>pixel type</strong>, not the <strong>image
type</strong>.  For instance, there are multiple <strong>image types</strong> where the
<strong>pixel type</strong> is <tt class="docutils literal">ONEBIT</tt> (OneBitImageView, Cc, OneBitRleImageView
etc.).  Therefore, you will normally want to have a helper function
which is templatized on the pixel type, which is called from the main
function.  See for example, the <tt class="docutils literal">invert</tt> plugin method, which needs
to do something different for FLOAT images (since the range of FLOAT
pixels is not fixed.):</p>
<div class="highlight"><pre><span></span><span class="cm">/* Invert an image */</span><span class="w"></span>

<span class="c1">// This is the generic version</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Pixel</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">invert_specialized</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ImageAccessor</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">vec_iterator</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">in</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">acc</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">invert</span><span class="p">(</span><span class="n">acc</span><span class="p">(</span><span class="n">in</span><span class="p">)),</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// This is specialized for FLOAT pixels</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">invert_specialized</span><span class="o">&lt;</span><span class="n">FloatPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FloatPixel</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_max</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">parent</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">ImageAccessor</span><span class="o">&lt;</span><span class="n">FloatPixel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">vec_iterator</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">vec_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">in</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">acc</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">max</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">acc</span><span class="p">(</span><span class="n">in</span><span class="p">),</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// This is the top level function that calls the correct</span>
<span class="c1">// specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">invert</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">invert_specialized</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">invert_special</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">invert_special</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="connected-components">
<h1><a class="toc-backref" href="#toc-entry-22">Connected components</a></h1>
<p>On the C++ side, the Python image type <tt class="docutils literal">Cc</tt> corresponds to the
image type <tt class="docutils literal">ConnectedComponent</tt>. You can us it just like in Python:</p>
<div class="highlight"><pre><span></span><span class="n">ImageList</span><span class="o">*</span><span class="w"> </span><span class="n">ccs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cc_analysis</span><span class="p">(</span><span class="n">image</span><span class="p">);</span><span class="w"></span>
<span class="n">ImageList</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">ccs_it</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="c1">// loop over all ccs</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ccs_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ccs</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">ccs_it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ccs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">ccs_it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">Cc</span><span class="o">*</span><span class="w"> </span><span class="n">cc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cc</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">ccs_it</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// query cc label</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Loop over individual pixels</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">nrows</span><span class="p">();</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">ncols</span><span class="p">();</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">is_black</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// .... }</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>For creating a list of CCs from C++, two steps are necessary:</p>
<blockquote>
<ol class="arabic">
<li><p class="first">Setting all pixels in the image to its label value</p>
</li>
<li><p class="first">Call the constructor for each ConnectedComponent:</p>
<div class="highlight"><pre><span></span><span class="c1">// Assumptions:</span>
<span class="c1">//   the CC labels have been stored in the vector &quot;labelvec&quot;</span>
<span class="c1">//   the CC dimensions have been stored in the vector &quot;rectvec&quot;</span>
<span class="n">ccs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ImageList</span><span class="p">();</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">labelvec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ccs</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ConnectedComponent</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">data_type</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">                   </span><span class="o">*</span><span class="p">((</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">data_type</span><span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span><span class="w"></span>
<span class="w">                   </span><span class="n">labelvec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"></span>
<span class="w">                   </span><span class="n">Point</span><span class="p">(</span><span class="n">rectvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset_x</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">offset_x</span><span class="p">(),</span><span class="w"></span>
<span class="w">                         </span><span class="n">rectvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset_y</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">offset_y</span><span class="p">()),</span><span class="w"></span>
<span class="w">                   </span><span class="n">rectvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">()</span><span class="w"></span>
<span class="w">                  </span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</li>
</ol>
</blockquote>
</div>
<div class="section" id="multi-label-connected-components">
<h1><a class="toc-backref" href="#toc-entry-23">Multi-label connected components</a></h1>
<p>On the C++ side, the Python image type <tt class="docutils literal">MlCc</tt> corresponds to the
image type <tt class="docutils literal">MultiLabelCC</tt> (two upper case C's at the end). Its
methods are the <a class="reference external" href="image_types.html#multi-label-connected-components">same as on the Python side</a>; for details about
its C++ constructors and properties (<tt class="docutils literal">m_labels</tt> etc.) see the
source file <em>include/connected_component.hpp</em> of the Gamera source
code.</p>
</div>
</div>
<div class="footer">
<hr class="footer" />
<span class="raw-html"><div style="text-align:right;">For contact information, see <a href="http://gamera.informatik.hsnr.de/contact.html">http://gamera.informatik.hsnr.de/contact.html</a></div></span>
</div>
</body>
</html>
