<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Writing Gamera Plugins</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="writing-gamera-plugins">
<h1 class="title">Writing Gamera Plugins</h1>

<p><strong>Last modified</strong>: October 23, 2022</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a><ul>
<li><a class="reference internal" href="#the-files-involved" id="toc-entry-2">The files involved</a><ul>
<li><a class="reference internal" href="#plugins-in-the-gamera-source-tree" id="toc-entry-3">Plugins in the Gamera source tree</a></li>
<li><a class="reference internal" href="#plugins-in-a-toolkit" id="toc-entry-4">Plugins in a toolkit</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#a-simple-example" id="toc-entry-5">A simple example</a><ul>
<li><a class="reference internal" href="#plugin-metadata" id="toc-entry-6">Plugin metadata</a></li>
<li><a class="reference internal" href="#c-code" id="toc-entry-7">C++ code</a></li>
<li><a class="reference internal" href="#building-the-plugin" id="toc-entry-8">Building the plugin</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-features" id="toc-entry-9">Advanced features</a><ul>
<li><a class="reference internal" href="#specifying-arguments" id="toc-entry-10">Specifying arguments</a></li>
<li><a class="reference internal" href="#free-functions" id="toc-entry-11">Free functions</a></li>
<li><a class="reference internal" href="#pure-python-methods" id="toc-entry-12">Pure Python methods</a></li>
<li><a class="reference internal" href="#free-pure-python-functions" id="toc-entry-13">Free pure Python functions</a></li>
<li><a class="reference internal" href="#raising-exceptions" id="toc-entry-14">Raising exceptions</a></li>
<li><a class="reference internal" href="#progress-bars" id="toc-entry-15">Progress bars</a><ul>
<li><a class="reference internal" href="#progress-bars-in-python" id="toc-entry-16">Progress Bars in Python</a></li>
<li><a class="reference internal" href="#progress-bars-in-c-plugins" id="toc-entry-17">Progress Bars in C++ Plugins</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documenting-and-unit-testing-plugin-functions" id="toc-entry-18">Documenting and unit-testing Plugin functions</a><ul>
<li><a class="reference internal" href="#examples" id="toc-entry-19">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#feature-generators-a-special-kind-of-plugin" id="toc-entry-20">Feature generators: A special kind of plugin</a></li>
<li><a class="reference internal" href="#further-reading" id="toc-entry-21">Further reading</a></li>
<li><a class="reference internal" href="#references" id="toc-entry-22">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#toc-entry-1">Introduction</a></h1>
<p>The functionality of Gamera can be extended by writing plugins in
either C++ or Python.  A plugin is simply a set of methods (which are
automagically added to the <tt class="docutils literal">Image</tt> class) or free-standing
functions.  Plugins are technically just Python modules, but with more
information that allows for easier wrapping and compilation of C++
methods and to support all kinds of automatic things in the graphical
user interface.</p>
<p>Plugins can also be grouped together, with other tools, into toolkits.
Toolkits provide higher-level workflow framework for end-to-end
document recognition by joining together a number of steps from
various plugins.  Toolkits are a whole other discussion, so see the
<a class="reference external" href="writing_toolkits.html">writing Gamera toolkits</a> for more information.</p>
<p>Before writing any plugin, you should make sure there isn't already a
plugin included that does what you want.  Look at the <a class="reference external" href="plugins.html">list of plugins
included with Gamera</a>.</p>
<div class="section" id="the-files-involved">
<h2><a class="toc-backref" href="#toc-entry-2">The files involved</a></h2>
<p>Each plugin is made up of two files:</p>
<ol class="arabic simple">
<li>A Python file that describes each method in the plugin and the
plugin itself.  If any methods are &quot;pure Python&quot;, they can also be
defined here, or they can just delegate to functions in other
Python modules.</li>
<li>Optionally, a C++ header file containing implementations of any C++
methods of the plugin.  This is a header file (<tt class="docutils literal">.hpp</tt>) and not an
implementation file (<tt class="docutils literal">.cpp</tt>) because the code you write will be templatized
and the concrete methods and the glue code connecting to Python to
C++ will be generated automatically at compile time by the Gamera
build system.  (What templates are is beyond the scope of this
document, but it's covered very well in <a class="citation-reference" href="#stroustrup1997" id="citation-reference-1">[Stroustrup1997]</a>.)</li>
</ol>
<div class="section" id="plugins-in-the-gamera-source-tree">
<h3><a class="toc-backref" href="#toc-entry-3">Plugins in the Gamera source tree</a></h3>
<p>The Python metadata files are stored in <tt class="docutils literal">./gamera/plugins/</tt> and the
C++ source files are stored in <tt class="docutils literal">./include/plugins</tt>.</p>
<p>If you keep these files in the proper directories, they will be
automatically picked up by the build system and compiled.  When Gamera
is started up, it will search the <tt class="docutils literal">./gamera/plugins</tt> directory and load
all plugins.</p>
</div>
<div class="section" id="plugins-in-a-toolkit">
<h3><a class="toc-backref" href="#toc-entry-4">Plugins in a toolkit</a></h3>
<p>In a toolkit, the Python metadata files are stored in
<tt class="docutils literal">./gamera/toolkits/my_toolkit/plugins/</tt> and the C++ source files are
stored in <tt class="docutils literal">./include/plugins</tt>, both rooted at the top of your
toolkit directory.</p>
<p>Plugin modules included in toolkits will have to be explicitly
imported before they are available.</p>
</div>
</div>
</div>
<div class="section" id="a-simple-example">
<h1><a class="toc-backref" href="#toc-entry-5">A simple example</a></h1>
<div class="section" id="plugin-metadata">
<h2><a class="toc-backref" href="#toc-entry-6">Plugin metadata</a></h2>
<p>Let's look at a simple metadata file, <tt class="docutils literal">example.py</tt>.  Each method is
described by creating a class that inherits from
<tt class="docutils literal">gamera.plugin.PluginFunction</tt> and defining a number of special
members.  The whole plugin is described by a class that inherits from
<tt class="docutils literal">gamera.plugin.PluginModule</tt>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gamera.plugin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">_example</span>

<span class="c1"># C++ method</span>
<span class="k">class</span> <span class="nc">volume</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the ratio of black pixels to white pixels within the</span>
<span class="sd">    bounding box of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>
    <span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ONEBIT</span><span class="p">,)]</span>

<span class="k">class</span> <span class="nc">ExampleModule</span><span class="p">(</span><span class="n">PluginModule</span><span class="p">):</span>
    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;Example&quot;</span>
    <span class="n">cpp_headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;example.hpp&quot;</span><span class="p">]</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">volume</span><span class="p">]</span>
    <span class="n">author</span> <span class="o">=</span> <span class="s2">&quot;Michael Droettboom and Karl MacMillan&quot;</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://gamera.informatik.hsnr.de/&quot;</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">ExampleModule</span><span class="p">()</span>
</pre></div>
<p>Okay, now let's break it down.</p>
<p>The <tt class="docutils literal">gamera.plugin</tt> module contains all of the utilities necessary to
create Gamera plugins, so the first thing we do is import it:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gamera.plugin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
<p>Next, we import the C++ (compiled object file) side of the plugin,
(described in the next section) which <em>always</em> has the same name as
the Python metadata module, except with a leading underscore:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">_example</span>
</pre></div>
<p>Let's start by describing a minimal C++ method.  All methods and
functions in a plugin are described using a class that inherits from
<tt class="docutils literal">gamera.plugin.PluginFunction</tt>:</p>
<div class="highlight"><pre><span></span><span class="c1"># C++ method</span>
<span class="k">class</span> <span class="nc">volume</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
</pre></div>
<p>Each plugin can (and should) be documented in the usual <a class="reference external" href="http://www.python.org/doc/current/tut/node6.html">Python
docstring</a> way:</p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Returns the ratio of black pixels to white pixels within the</span>
<span class="sd">bounding box of the image.</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
<p>On a related note, you can also have the documentation system
(<tt class="docutils literal">doc/gendoc.py</tt>) generate an example automatically.  See
<a class="reference internal" href="#documenting-and-unit-testing-plugin-functions">documenting and unit-testing Plugin functions</a>.</p>
<p>Next, we define <tt class="docutils literal">self_type</tt>, which is the type of object this method
can be called on.  If <tt class="docutils literal">self_type</tt> is an <tt class="docutils literal">ImageType</tt>, the method
will automatically be added to all <tt class="docutils literal">Image</tt> objects in Gamera
whenever the plugin is imported.  Within the <tt class="docutils literal">ImageType</tt> specifier,
you can choose which types of pixels are supported using a list of
pixel type names. Valid options are <tt class="docutils literal">ONEBIT</tt>, <tt class="docutils literal">GREYSCALE</tt>,
<tt class="docutils literal">GREY16</tt>, <tt class="docutils literal">FLOAT</tt> and <tt class="docutils literal">RGB</tt> (these are all constants imported
from the <tt class="docutils literal">gamera.plugin module</tt>):</p>
<div class="highlight"><pre><span></span><span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">])</span>
</pre></div>
<p>You can also optionally define <tt class="docutils literal">return_type</tt>.  This specifier is
used to generate a variable name for the result in the GUI, and so the
C++ wrapping mechanism knows how to return the result to Python.  If
you don't specify a return type, Gamera assumes there is no return
result:</p>
<div class="highlight"><pre><span></span><span class="n">return_type</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>
</pre></div>
<p>Obviously, this is a very simple plugin method with no arguments.
Some more involved examples are given below.  In the meantime, let's
look at how this method is contained in a plugin module.</p>
<p>For each plugin module, you also need a class to describe the entire
plugin.  There may be <em>only one</em> of these classes per plugin.  This is
done in a similar manner to how the methods are described.</p>
<p>There is a class that inherits from <tt class="docutils literal">gamera.plugin.PluginModule</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExampleModule</span><span class="p">(</span><span class="n">PluginModule</span><span class="p">):</span>
</pre></div>
<p>You can specify a category for the plugin's methods on
the context (right-click) menu in the GUI:</p>
<div class="highlight"><pre><span></span><span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;Example&quot;</span>
</pre></div>
<p>If you have any C++ methods (which we do in this case), you must
specify the C++ header files to include which contain the
corresponding method's source code:</p>
<div class="highlight"><pre><span></span><span class="n">cpp_headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;example.hpp&quot;</span><span class="p">]</span>
</pre></div>
<p>You must also list all of the plugins and methods in the file so they
can be generated and loaded:</p>
<div class="highlight"><pre><span></span><span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">volume</span><span class="p">]</span>
</pre></div>
<p>Optionally, the author names and a URL for more information can be
specified:</p>
<div class="highlight"><pre><span></span><span class="n">author</span> <span class="o">=</span> <span class="s2">&quot;Michael Droettboom and Karl MacMillan&quot;</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://gamera.informatik.hsnr.de/&quot;</span>
</pre></div>
<p>Lastly, we create an instance of this class so the module loader can
do its work:</p>
<div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="n">ExampleModule</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="c-code">
<h2><a class="toc-backref" href="#toc-entry-7">C++ code</a></h2>
<p>Since the <tt class="docutils literal">volume</tt> method needs to look at individual pixels, it is
likely going to be much faster written in C++ than in Python.  Below
is the corresponding <tt class="docutils literal">example.hpp</tt> that contains the C++
implementation:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gamera.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Gamera</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">volume</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_vec_iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">vec_end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_black</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">feature_t</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">nrows</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">ncols</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Most of the declarations needed for Gamera are in <tt class="docutils literal">gamera.hpp</tt>, and
all of that stuff is in the <tt class="docutils literal">Gamera</tt> namespace, to prevent name
collisions.  You may find it most convenient to just put <tt class="docutils literal">using
namespace Gamera</tt> at the top of your plugin file, rather than
specifying <tt class="docutils literal"><span class="pre">Gamera::...</span></tt> everywhere:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gamera.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Gamera</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Next we get to the function itself.  Note that it is templatized.
Since it is our goal to write a single algorithm that may work on
multiple image types, <em>all</em> plugin methods are templatized, and the
instantiations of these templates are generated by the Gamera build
system at compile-time based on the <tt class="docutils literal">self_type</tt> specifier in the
method metadata class (that we specified in <tt class="docutils literal">example.py</tt>).  See how
the first argument <tt class="docutils literal">self</tt> is templatized as <tt class="docutils literal">T</tt> so that any
(image) type can be passed in.  The body of the function used the
<a class="reference external" href="image_api.html">Gamera C++ Image API</a> to access and examine the individual pixels:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">volume</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_vec_iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">vec_begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">vec_end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_black</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">feature_t</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">nrows</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">ncols</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="building-the-plugin">
<h2><a class="toc-backref" href="#toc-entry-8">Building the plugin</a></h2>
<p>Okay, so now we're done with the minimal plugin, but obviously
something more has to happen in order to access the C++ code from Python.
Fortunately, that is all done automatically by the Gamera build
system.  If the <tt class="docutils literal">example.py</tt> is placed in the <tt class="docutils literal">./gamera/plugins</tt>
directory, the build system will automatically find it, use the
metadata to generate a <em>wrapper</em> to access <tt class="docutils literal">example.hpp</tt>, and compile
everything.  The next time Gamera is run, the plugin will
automatically be loaded.  The plugin author does not have to learn
about the intricacies of the <a class="reference external" href="http://www.python.org/doc/current/api/api.html">Python/C API</a>.</p>
<p>But, for the sake of some sick curiosity, the generated code looks
something like:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Python.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gameramodule.hpp&quot;</span><span class="cp"></span>

<span class="n">init_features</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Py_InitModule</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;_features&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_features_methods</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;features.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Gamera</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_example</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">call_volume</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="n">_features_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;volume&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">call_volume</span><span class="p">,</span><span class="w"> </span><span class="n">METH_VARARGS</span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">call_volume</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">real_self</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Image</span><span class="w"> </span><span class="o">*</span><span class="n">real_self_image</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">FloatVector</span><span class="w"> </span><span class="o">*</span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;O&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">real_self</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_ImageObject</span><span class="p">(</span><span class="n">real_self</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Object is not an image as expected!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">real_self_image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">Image</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">RectObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">real_self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">image_get_fv</span><span class="p">(</span><span class="n">real_self</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">real_self_image</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">real_self_image</span><span class="o">-&gt;</span><span class="n">features_len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">get_image_combination</span><span class="w"> </span><span class="p">(</span><span class="n">real_self</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">ONEBITRLEIMAGEVIEW</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volume</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">OneBitRleImageView</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">real_self_image</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">RLECC</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volume</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">RleCc</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">real_self_image</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">CC</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volume</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">Cc</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">real_self_image</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">ONEBITIMAGEVIEW</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">OneBitImageView</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">real_self_image</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="w"> </span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="s">&quot;Image types do not match function signature.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">PyErr_SetString</span><span class="w"> </span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">array_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_ArrayInit</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array_init</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyString_FromStringAndSize</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">return_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">])),</span><span class="w"></span>
<span class="w">                                </span><span class="n">return_value</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_CallFunction</span><span class="p">(</span><span class="n">array_init</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sO&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">return_value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">DL_EXPORT</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">init_example</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Py_InitModule</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;_example&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_example_methods</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><strong>Aren't you glad you don't have to write something like that every
time!</strong></p>
</div>
</div>
<div class="section" id="advanced-features">
<h1><a class="toc-backref" href="#toc-entry-9">Advanced features</a></h1>
<div class="section" id="specifying-arguments">
<h2><a class="toc-backref" href="#toc-entry-10">Specifying arguments</a></h2>
<p>Of course, many plugin methods will need to have arguments.  See this
<tt class="docutils literal">resize_copy</tt> method, for example:</p>
<div class="highlight"><pre><span></span><span class="c1"># C++ image method with some arguments</span>
<span class="k">class</span> <span class="nc">resize_copy</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies and resizes an image. In addition to size the type of</span>
<span class="sd">    interpolation can be specified to allow tradeoffs between speed</span>
<span class="sd">    and quality.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;Utility/Copy&quot;</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">,</span> <span class="n">GREYSCALE</span><span class="p">,</span> <span class="n">GREY16</span><span class="p">,</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="n">RGB</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Args</span><span class="p">([</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;nrows&quot;</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="s2">&quot;ncols&quot;</span><span class="p">),</span>
                <span class="n">Choice</span><span class="p">(</span><span class="s2">&quot;Interpolation Type&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;Linear&quot;</span><span class="p">,</span> <span class="s2">&quot;Spline&quot;</span><span class="p">])])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">,</span> <span class="n">GREYSCALE</span><span class="p">,</span> <span class="n">GREY16</span><span class="p">,</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="n">RGB</span><span class="p">])</span>
</pre></div>
<p>And the corresponding C++ declaration:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Image</span><span class="o">*</span><span class="w"> </span><span class="n">resize_copy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nrows</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ncols</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">resize_quality</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The <tt class="docutils literal">args</tt> member variable specifies a list of the arguments that
are passable to the method.  Note that this does not include the first
&quot;argument&quot; to the C++ function, which always corresponds to
<tt class="docutils literal">self_type</tt>.  This specification is used to generate wrapper code,
and also to generate dialog boxes in the GUI.  The format of these
argument lists are documented in <a class="reference external" href="args.html">Specifying arguments</a>.</p>
<p>The <em>args</em> parameter in the plugin prototype allows the specification of
default values for arguments. These are however used only in the GUI for
the argument dialog box. If you need an actual default argument for your
plugin function, you must define the <tt class="docutils literal">__call__</tt> method in your plugin, e.g.</p>
<div class="highlight"><pre><span></span>  <span class="c1"># wrapper for passing a default argument</span>
  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;Linear&quot;</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">_example</span><span class="o">.</span><span class="n">resize_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
<span class="fm">__call__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="fm">__call__</span><span class="p">)</span>
</pre></div>
<p><tt class="docutils literal">_example</tt> must be replaced by the actual name of your source file plus
a leading underscore.</p>
</div>
<div class="section" id="free-functions">
<h2><a class="toc-backref" href="#toc-entry-11">Free functions</a></h2>
<p>It doesn't always make sense to have everything be a method of images.
For example, you may want to create a function that requires a list of
images as input.  Fortunately, you can still use the plugin system to
automate the wrapping/building process, while foregoing the automatic
inclusion of the method in the Image class and on the right-click
context menu. It's as simple as setting <tt class="docutils literal">self_type</tt> to <tt class="docutils literal">None</tt> in
the metadata object:</p>
<div class="highlight"><pre><span></span><span class="c1"># C++ free function</span>
<span class="k">class</span> <span class="nc">union_images</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a new image by overlaying all the images in the given list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Args</span><span class="p">([</span><span class="n">ImageList</span><span class="p">(</span><span class="s1">&#39;list_of_images&#39;</span><span class="p">)])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">])</span>
</pre></div>
<p>As these functions are not image methods, but standalone <em>callable</em> classes,
you additionally must create an instance of this class in the same python
metadata file:</p>
<div class="highlight"><pre><span></span><span class="n">union_images</span> <span class="o">=</span> <span class="n">union_images</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="pure-python-methods">
<h2><a class="toc-backref" href="#toc-entry-12">Pure Python methods</a></h2>
<p>Sometimes there is not much efficiency to be gained by writing the
plugin method in C++, or you want the flexibility of Python for
experimentation.  In that case you can implement the method in pure
Python.  Everything else is the same, except you add a <tt class="docutils literal">__call__</tt>
method with the Python implementation.  It is important that this
method is a <tt class="docutils literal">staticmethod</tt>, since the first <tt class="docutils literal">self</tt> argument is
going to be an <tt class="docutils literal">Image</tt> object and not a <tt class="docutils literal">PluginFunction</tt> object:</p>
<div class="highlight"><pre><span></span><span class="c1"># Python image method</span>
<span class="k">class</span> <span class="nc">area</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the aspect ratio of the bounding box of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">,</span> <span class="n">GREYSCALE</span><span class="p">,</span> <span class="n">GREY16</span><span class="p">,</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="n">RGB</span><span class="p">])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
    <span class="n">pure_python</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
    <span class="fm">__call__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="fm">__call__</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="free-pure-python-functions">
<h2><a class="toc-backref" href="#toc-entry-13">Free pure Python functions</a></h2>
<p>Since the plugin modules are also just regular Python modules
underneath, it is of course possible to just add ordinary Python
functions as well:</p>
<div class="highlight"><pre><span></span><span class="c1"># Python free function</span>
<span class="k">def</span> <span class="nf">filter_small_images</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ncols</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">nrows</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="raising-exceptions">
<h2><a class="toc-backref" href="#toc-entry-14">Raising exceptions</a></h2>
<p>The convention in Gamera is to use exceptions for error conditions
rather than by using error codes.</p>
<p>C++ exceptions are automatically propagated to Python.  (All C++
exception types will be converted to Python <tt class="docutils literal">RuntimeError</tt>.)</p>
<div class="highlight"><pre><span></span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Input is out of range&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>From pure Python functions, the standard Python exception mechanism
can be used:</p>
<div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Input is out of range&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="progress-bars">
<h2><a class="toc-backref" href="#toc-entry-15">Progress bars</a></h2>
<p>This section describes how to display a progress bar dialog from a
long-running plugin. When the GUI is running, the progress
will be displayed in a window:</p>
<blockquote>
<img alt="images/progress_bar.png" src="images/progress_bar.png" />
</blockquote>
<p>It is also possible to display a progress bar made from text characters
in the console, when the GUI is not running. To make it appear, set
the config option <em>progress_bar</em> to <tt class="docutils literal">True</tt> as follows:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gamera.config</span> <span class="kn">import</span> <span class="n">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;progress_bar&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Progress bars will add some overhead when displayed, so they
only make sense for plugins that take a long time to complete.
Supporting progress bars adds very minimal overhead when they are not
displayed.</p>
<div class="section" id="progress-bars-in-python">
<h3><a class="toc-backref" href="#toc-entry-16">Progress Bars in Python</a></h3>
<p>To create a progress bar that is a message box in the GUI and
a text line in a non GUI script, you can use the <tt class="docutils literal">ProgressFactory</tt>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gamera.util</span> <span class="kn">import</span> <span class="n">ProgressFactory</span>
<span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressFactory</span><span class="p">(</span><span class="s2">&quot;Title&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">numsteps</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
<p>where <em>length</em> is the total number of which the progress fraction is to
be shown. The optional argument <em>numsteps</em> can be useful to reduce
the overhead by only updating the progress bar in <em>numsteps</em> discrete steps;
when zero, every update call will result in an update of the progress bar.</p>
<p>To update the progress bar, there are two alternative methods:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">.step()</tt> increases the progress counter by one. Whether the
displayed progress bar actually is updated depends on <em>numsteps</em>.</li>
<li><tt class="docutils literal">.update(steps, length)</tt> sets the progress bar to the
<em>steps</em>/<em>length</em> fraction.</li>
</ul>
</blockquote>
</div>
<div class="section" id="progress-bars-in-c-plugins">
<h3><a class="toc-backref" href="#toc-entry-17">Progress Bars in C++ Plugins</a></h3>
<p>To create a plugin method with a progress bar, simply set the
<tt class="docutils literal">progress_bar</tt> member to the message that will be displayed in the
progress box.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">cc_analysis</span><span class="p">(</span><span class="n">Segmenter</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="n">progress_bar</span> <span class="o">=</span> <span class="s2">&quot;Generating connected components&quot;</span>
  <span class="o">...</span>
</pre></div>
<p>Add an extra argument to the C++ function that takes an object of type
<tt class="docutils literal">ProgressBar</tt>.  This can be a default argument, to make it easier to
call the plugin function code without requiring a <tt class="docutils literal">ProgressBar</tt> instance.
Creating a <tt class="docutils literal">ProgressBar</tt> with no constructor arguments creates a
dummy <tt class="docutils literal">ProgressBar</tt> object where all methods are ignored.</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">ImageList</span><span class="o">*</span><span class="w"> </span><span class="n">cc_analysis</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">ProgressBar</span><span class="w"> </span><span class="n">progress_bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ProgressBar</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The progress bar window will automatically disappear when the function returns.</p>
<p>There are essentially two ways to update the progress bar:</p>
<blockquote>
<ul class="simple">
<li>Call <tt class="docutils literal"><span class="pre">.set_length(*length*)</span></tt> to set the number of steps that will be
performed, and then call <tt class="docutils literal">.step()</tt> to increase the step.</li>
<li>Call <tt class="docutils literal"><span class="pre">.update(*num*,</span> *den*)</tt> to say that <em>num</em> of <em>den</em> steps
have completed.  <tt class="docutils literal">.update</tt> is useful when the number of steps can
not be pre-determined.</li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="documenting-and-unit-testing-plugin-functions">
<h2><a class="toc-backref" href="#toc-entry-18">Documenting and unit-testing Plugin functions</a></h2>
<p>The docstring of each <tt class="docutils literal">PluginFunction</tt> class is used like a regular
Python docstring, but also has the following advantages in Gamera:</p>
<blockquote>
<ul class="simple">
<li>It will be included in the automatically generated HTML
documentation.</li>
<li>It is displayed in the Documentation pane in the Gamera shell
window.</li>
<li>It is displayed in the automatically-generated dialog box for the
plugin.</li>
</ul>
</blockquote>
<p>The docstrings should be formatted in <a class="reference external" href="http://structuredtext.sourceforge.net">reStructuredText</a>, which is
becoming a de-facto Python standard for documentation, as well as
being rather easy to read and use.</p>
<p>The Gamera documentation can be regenerated by going to the <tt class="docutils literal">doc</tt>
directory (in the source distribution) and running the <tt class="docutils literal">gendoc.py</tt>
script:</p>
<pre class="literal-block">
python gendoc.py
</pre>
<p>In addition to text, image examples can be generated on-the-fly and
included in the documentation using the <tt class="docutils literal">doc_examples</tt> member.  The
<tt class="docutils literal">doc_examples</tt> mechanism is also used to write rudimentary
unit-tests for Gamera's <a class="reference external" href="unit_testing.html">unit-testing framework</a>.</p>
<p>The <tt class="docutils literal">doc_examples</tt> member is a list of tuples or functions:</p>
<ul>
<li><p class="first">If the element is a tuple, it is a list of arguments that will be
passed into the plugin method to create an example.  Where image
arguments are expected, image type identifiers can be used, which
will load a standard image from disk and use it.  For example:</p>
<pre class="literal-block">
(ONEBIT, 52, 32)
</pre>
<p>will use the standard OneBit image and the arguments of <tt class="docutils literal">52, 32</tt>.</p>
</li>
<li><p class="first">If the element is a function, that function will be called to create
the example.  The function will be passed one argument, <tt class="docutils literal">images</tt>,
which is a dictionary of the standard Gamera example images.  Any
images or values returned will be included in the documentation.
Any exceptions raised by the function will be logged by the
unit-testing framework when it is run.  For example the following
loads the standard RGB and GreyScale images, clips them
appropriately, adds them together, and then returns all of them for
inclusion in the documentation.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__doc_example1__</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="n">rgb</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">RGB</span><span class="p">]</span>
    <span class="n">greyscale</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">GREYSCALE</span><span class="p">]</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">rgb</span><span class="o">.</span><span class="n">clip_image</span><span class="p">(</span><span class="n">greyscale</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">clipped</span><span class="p">,</span> <span class="n">greyscale</span><span class="p">,</span>
            <span class="n">clipped</span><span class="o">.</span><span class="n">add_images</span><span class="p">(</span><span class="n">greyscale</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)]</span>
<span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">__doc_example1__</span><span class="p">]</span>
</pre></div>
<div class="section" id="examples">
<h3><a class="toc-backref" href="#toc-entry-19">Examples</a></h3>
<p>The following <tt class="docutils literal">doc_examples</tt> specifier (from <a class="reference external" href="convolution.html#simple-sharpen">simple_sharpen</a>)
produces two examples, one on the standard GREYSCALE image, and
another on the standard RGB image, using different values for the
<em>sharpening_factor</em>.</p>
<div class="highlight"><pre><span></span><span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">GREYSCALE</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="n">RGB</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)]</span>
</pre></div>
<p>For <a class="reference external" href="draw.html#draw-bezier">draw_bezier</a>, a custom example function was used, which does
not load a standard image.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__doc_example1__</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
    <span class="kn">from</span> <span class="nn">gamera.core</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">Dim</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Dim</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">RGB</span><span class="p">,</span> <span class="n">DENSE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">image</span><span class="o">.</span><span class="n">draw_bezier</span><span class="p">((</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span>
                          <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span>
                          <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span>
                          <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span>
                          <span class="n">RGBPixel</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                          <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">),</span>
                          <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">image</span>
<span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">__doc_example1__</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="feature-generators-a-special-kind-of-plugin">
<h1><a class="toc-backref" href="#toc-entry-20">Feature generators: A special kind of plugin</a></h1>
<p>Plugin methods that take an image as input and generate some floating
point features from it are called &quot;feature generators&quot;.  The resulting
floating point features are used by the classifier to classify images.</p>
<p>For efficiency reasons, feature generator functions are implemented
slightly differently from a regular <tt class="docutils literal">PluginFunction</tt>.  Rather than
returning the features as a return value, which would require a memory
copy into the image's feature vector, feature generators write
directly to a buffer that is passed in as an argument.</p>
<p>As an example, let's look at the <tt class="docutils literal">nholes</tt> feature generator.  The
Python metadata is the same as you would expect, except the member
<tt class="docutils literal">feature_function</tt> is set to <tt class="docutils literal">True</tt>.  This will tell the build
system to treat this plugin method as a feature generator with the
different return value behavior.  The <tt class="docutils literal">return_type</tt> must be a
<tt class="docutils literal">FloatVector</tt>, where <tt class="docutils literal">length</tt> indicates the number of feature
values that are generated.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">nholes</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the average number of transitions from white to black</span>
<span class="sd">    in each row or column.</span>

<span class="sd">    The elements of the returned ``FloatVector`` are:</span>

<span class="sd">    0. vertical</span>
<span class="sd">    1. horizontal</span>

<span class="sd">    These features are scale invariant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">FloatVector</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">feature_function</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ONEBIT</span><span class="p">,)]</span>
</pre></div>
<p>On the C++ side, the function takes two arguments: the image, and a
pointer to a floating point buffer.  Note that the return type is <tt class="docutils literal">void</tt>.</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">nholes</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">feature_t</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">vert</span><span class="p">,</span><span class="w"> </span><span class="n">horiz</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">vert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nholes_1d</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">col_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">col_end</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">horiz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nholes_1d</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">row_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">row_end</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="p">(</span><span class="n">buf</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">feature_t</span><span class="p">)</span><span class="n">vert</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">ncols</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">feature_t</span><span class="p">)</span><span class="n">horiz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">nrows</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>(The C++ function <tt class="docutils literal">nholes_1d</tt> is where all the real work gets done,
and is not important for this illustration.)  Note how the result of the
function is copied directly into the buffer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is extremely important not to write more values to the
buffer than is defined in the metadata <tt class="docutils literal">return_value</tt>.  Doing so
could cause Python/Gamera to behave erratically or segfault.</p>
</div>
<p>It is also possible to write a feature generator in pure Python.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">nholes</span><span class="p">(</span><span class="n">PluginFunction</span><span class="p">):</span>
    <span class="n">self_type</span> <span class="o">=</span> <span class="n">ImageType</span><span class="p">([</span><span class="n">ONEBIT</span><span class="p">])</span>
    <span class="n">return_type</span> <span class="o">=</span> <span class="n">FloatVector</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">feature_function</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">doc_examples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ONEBIT</span><span class="p">,)]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span>

        <span class="c1"># Do some processing to get values...</span>

        <span class="n">buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">result1</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">result2</span>
    <span class="fm">__call__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="fm">__call__</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="further-reading">
<h1><a class="toc-backref" href="#toc-entry-21">Further reading</a></h1>
<ul class="simple">
<li><a class="reference external" href="image_api.html">Writing C++ plugin methods that processes Gamera images</a></li>
</ul>
<ul class="simple">
<li><a class="reference external" href="args.html">Specifying arguments</a></li>
</ul>
<ul class="simple">
<li><a class="reference external" href="plugins_custom_types.html">Passing/returning custom data types to/from plugins</a></li>
</ul>
<ul class="simple">
<li><a class="reference external" href="writing_toolkits.html">Grouping plugins together into toolkits</a></li>
</ul>
<ul class="simple">
<li>And of course, there's lots of examples in the Gamera code itself!</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#toc-entry-22">References</a></h1>
<table class="docutils citation" frame="void" id="stroustrup1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-1">[Stroustrup1997]</a></td><td>Stroustrup, B. 1997. <em>The C++ Programming
Language: Third Edition.</em>  Reading, MA: Addison-Wesley.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="footer">
<hr class="footer" />
<span class="raw-html"><div style="text-align:right;">For contact information, see <a href="http://gamera.informatik.hsnr.de/contact.html">http://gamera.informatik.hsnr.de/contact.html</a></div></span>
</div>
</body>
</html>
